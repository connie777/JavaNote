乐观锁和悲观锁

悲观锁（Pessimistic Lock）：每次读写数据的时候总会认为数据会被别人修改，所以将数据加锁，置于锁定状态，不让别人再访问。如果持有锁的时间太长，其他用户需要等待很长时间。独占锁
	例：java中的synchronized和ReentrantLock重入锁，数据库中表锁、行锁、读写锁等。
	行锁就是操作数据的时候把这一行数据锁住，其他线程想要读写必须等待，但同一个表的其他数据还是能被其他线程操作的。只要在需要查询的sql后面加上for update，就能锁住查询的行，特别要注意查询条件必须要是索引列，如果不是索引就会变成表锁，把整个表都锁住。

乐观锁（Optimistic Lock）：每次读取数据时认为别人不会修改，不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去修改。所以悲观锁是限制其他线程，乐观锁是限制自己。虽然他的名字有锁，但实际上不算锁，通常为version版本号机制。
	例：CAS算法。
	版本号机制就是在数据库中加一个字段version当作版本号。那么获取Article的时候就会带一个版本号，比如version=1，然后你对这个Article一波操作，操作完之后要插入到数据库了。校验一下version版本号，发现在数据库里对应Article记录的version=2，这和我手里的版本不一样啊，说明提交的Article不是最新的，那么就不能update到数据库了，需要重新读取数据或抛异常。

什么时候用悲观锁或者乐观锁
	悲观锁适合写多读少的场景。因为在使用的时候该线程会独占这个资源，就适合用悲观锁，否则用户只是浏览文章（读），用悲观锁就会经常加锁，增加了加锁解锁的资源消耗。（适合冲突多加锁独占）

	乐观锁适合写少读多的场景。由于乐观锁在发生冲突时会回滚或重试，如果写的请求量很大的话，就经常发生冲突，结合事务会有经常的回滚和重试，这样对系统资源消耗也是非常大。（适合冲突少）

	阿里开发手册： 如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。


